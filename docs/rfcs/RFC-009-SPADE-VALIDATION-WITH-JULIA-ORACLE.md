# RFC-009: Spade Validation & Oracle Testing with DelaunayTriangulation.jl

**Status:** Draft
**Phase:** Post-port validation
**Complexity:** ⭐⭐ Medium
**Dependencies:** RFC-001 (Master Strategy), RFC-002–RFC-006 (core phases), RFC-008 (Advanced Voronoi & Power Diagrams)
**External References:**
- DelaunayTriangulation.jl (Julia) - MIT licensed
- Spade (Rust) test suite
- RFC-033 (Spade Performance Benchmarking Suite)

---

## Goal

Define a **validation and oracle testing strategy** for Spade on .NET using DelaunayTriangulation.jl as a reference implementation for selected scenarios.

This RFC focuses on **testing and diagnostics**, not new public APIs.

---

## Motivation

Spade on .NET aims for:

- Correctness equivalent to the Rust Spade implementation
- Robust behavior on challenging inputs (degeneracies, curve-bounded domains)
- Confidence when adding advanced features (RFC-008)

DelaunayTriangulation.jl provides:

- A mature, heavily-tested implementation of Delaunay triangulation and Voronoi diagrams
- Support for advanced cases (weighted, clipped, curve-bounded)
- A rich validation culture (e.g., `validation.jl`)

Using it as an **oracle** for targeted test cases helps:

- Detect discrepancies between Spade and another high-quality implementation
- Validate new features before exposing them publicly
- Provide regression tests for future changes

---

## Scope

### In Scope

- Defining **invariants** and structural checks for triangulations and Voronoi diagrams
- Designing a **cross-language testing harness** to compare Spade output with DelaunayTriangulation.jl
- Integrating oracle-based tests into the Spade test suite (e.g., `Spade.Tests.Validation`)

### Out of Scope

- Running Julia-based validation on every PR in CI (expensive)
- Re-implementing Julia validation logic verbatim
- Using Julia for performance benchmarking (handled in RFC-033)

---

## Validation Invariants

We define a set of invariants that a "good" triangulation / Voronoi diagram should satisfy. Examples:

### Triangulation Invariants

- **Topology:**
  - Each undirected edge has exactly two directed edges (twins)
  - DCEL connectivity is consistent (next, twin, origin, face)
- **Delaunay Property:**
  - For each triangle, the circumcircle contains no other points in its interior (within tolerance)
- **Boundary Handling:**
  - Convex hull edges are correctly identified
  - No disconnected components unless input is explicitly disconnected

### Voronoi Invariants

- **Duality:**
  - Voronoi diagram is dual to the Delaunay triangulation
  - Neighbors in Voronoi correspond to edges in triangulation
- **Cell Properties:**
  - Cells for interior points are bounded when the domain is bounded
  - Border cells are correctly flagged
- **Clipping (for advanced features):**
  - Clipped cells respect the clip domain boundaries

These invariants can be checked either:

- Purely within Spade (no Julia required), or
- By comparing with DelaunayTriangulation.jl outputs.

---

## Oracle Testing Strategy

### Overview

1. **Generate test inputs** (point sets, domains, weights) in .NET.
2. **Export** these inputs in a simple, language-agnostic format (e.g., JSON or CSV).
3. **Run DelaunayTriangulation.jl** with these inputs (offline or in a separate step) to generate reference outputs.
4. **Compare** Spade outputs against the Julia oracle within the .NET test suite.

### Data Exchange Format

Define a minimal exchange format, for example:

```json
{
  "points": [
    { "x": 0.1, "y": 0.2 },
    { "x": 0.5, "y": 0.8 }
  ],
  "weights": [0.0, 1.5],
  "domain": {
    "type": "polygon",
    "vertices": [ { "x": 0.0, "y": 0.0 }, ... ]
  }
}
```

Spade tests can:

- Write inputs to `ref-projects/DelaunayTriangulation.jl/tests/oracle_inputs/`.
- Read back oracle outputs from `oracle_outputs/` (generated by a Julia script).

### Comparison Strategy

Given numerical differences and implementation detail differences, comparisons should be tolerant:

- Use approximate equality for coordinates (e.g., epsilon-based comparisons)
- Focus on structural properties:
  - Adjacency graphs (neighbors)
  - Cell topology (number of neighbors, rough shape)
- Allow multiple valid triangulations/Voronoi diagrams for the same inputs (e.g., small perturbations)

---

## Test Integration

### Test Categories

1. **Smoke Tests:**
   - Small random point sets (10–100 points)
   - Simple domains (unit square, circle approximations)

2. **Degeneracy Tests:**
   - Collinear points
   - Near-duplicate points
   - Points on domain boundaries

3. **Advanced Feature Tests (RFC-008):**
   - Weighted triangulations
   - Clipped / centroidal Voronoi diagrams
   - Curve-bounded domains

### Test Locations

- New test project folder: `tests/Spade.Tests/Validation/`
- Example test files:
  - `DelaunayOracleTests.cs`
  - `VoronoiOracleTests.cs`
  - `WeightedOracleTests.cs` (future)

---

## Tooling & Workflow

### Julia Side

- Add scripts under `ref-projects/DelaunayTriangulation.jl/test_oracle/`:
  - `run_oracle_tests.jl`:
    - Reads JSON inputs from a specified directory
    - Runs triangulation / Voronoi / power diagram operations
    - Writes JSON outputs for .NET tests to consume

### .NET Side

- Add helper utilities (internal) for:
  - Writing input JSON files for Julia
  - Reading output JSON files
  - Converting between JSON structures and Spade data structures

### CI Integration

- Run oracle tests:
  - **Option 1:** Manually / on-demand (developer script)
  - **Option 2:** Periodically in CI (e.g., nightly or weekly job)

Given the dependency on Julia tooling and the size of the DelaunayTriangulation.jl repo, CI integration should be **opt-in** and not required for every PR.

---

## Implementation Plan (High Level)

### Phase 1: Define Invariants & Formats

- [ ] Write down concrete invariants to check in triangulations and diagrams.
- [ ] Define and document JSON schemas for inputs/outputs.

### Phase 2: Prototype Oracle Harness

- [ ] Implement minimal JSON export/import utilities in .NET (internal only).
- [ ] Write a simple Julia script that:
  - Reads one input file
  - Produces one output file with triangulation/Voronoi data
- [ ] Create a handful of manual tests that exercise the pipeline end-to-end.

### Phase 3: Integrate into Test Suite

- [ ] Add `Spade.Tests.Validation` tests that use pre-generated oracle outputs.
- [ ] Gate oracle tests behind a flag or explicit test category (e.g., `[Trait("Category", "Oracle")]`).
- [ ] Document how to regenerate oracle outputs when algorithms change.

---

## Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|-----------|
| CI complexity due to Julia dependency | Medium | Keep oracle tests optional; run only in specific pipelines |
| Divergent semantics between implementations | Medium | Focus on structural invariants and tolerant numerical comparisons |
| Oracle becoming stale as Spade evolves | Medium | Document regeneration procedure; re-run periodically |
| Overreliance on one external implementation | Low | Treat Julia as one reference, not absolute truth |

---

## Acceptance Criteria

- ✅ Clear list of invariants and what constitutes a "valid" triangulation / Voronoi diagram.
- ✅ Defined JSON formats for oracle tests.
- ✅ Documented workflow for using DelaunayTriangulation.jl as an oracle.
- ✅ At least a small set of oracle-based tests planned in `Spade.Tests.Validation`.
